<?php

namespace App\Controller\Ajax\Meteo;

use App\Entity\Composant;
use App\Entity\Meteo\Validation;
use App\Entity\Service;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class ExploitantController extends AbstractController
{
    /**
     * @Route(
     *     "/ajax/meteo/exploitants/{id}/composants/{periodeDebut}",
     *     methods={"GET"},
     *     name="ajax-meteo-exploitants-composants",
     *     requirements={"periodeDebut"="\d{8}"}
     * )
     */
    public function composantsExploitants(Service $service = null, Request $request): Response
    {
        // On initialise quelques variables
        $em = $this->getDoctrine()->getManager();
        $periodeDebut = \DateTime::createFromFormat('Ymd', $request->get('periodeDebut'));
        $validationDate = null;

        // On récupère les composants associés au service (et sous-services si structure de rattachement)
        if ($service === null) {
            $composants = $em->getRepository(Composant::class)->listeComposants();
        } else {
            // On regarde si le service a validé la publication de la météo pour cette période
            $validationDate = $em->getRepository(Validation::class)->validationDateParExploitantPeriode($service, $periodeDebut);

            $composants = $em->getRepository(Composant::class)->createQueryBuilder('c')
                ->select('c')
                ->join('c.exploitant', 'ex')
                ->andWhere('c.meteoActive = true')
                ->andWhere('c.archiveLe IS NULL')
                ->andWhere('ex.id = :exploitant OR ex.structurePrincipale = :exploitant')
                    ->setParameter('exploitant', $service)
                ->orderBy('c.label', 'ASC')
                ->getQuery()->getResult();
        }

        // On récupère les évènements associés aux composants
        $idsComposants = array_column($composants, 'id');
        $meteoComposants = $em->getRepository(Composant::class)->indicesMeteoComposants($idsComposants, $periodeDebut);

        // On ajoute le href pour l'affichage
        $meteoComposants = array_map(function ($meteo) use ($request, $service) {
            if ($request->get('saisie', false)) {
                $meteo['href'] = $this->generateUrl('meteo-composant-modifier', [
                    'composant' => $meteo['id'],
                    'dateDebut' => $request->get('periodeDebut'),
                ]);

                if ($this->isGranted(Service::ROLE_GESTION)) {
                    $meteo['href'] .= '?s=' . $service->getId();
                }
            } else {
                $meteo['href'] = $this->generateUrl('meteo-visualisation', [
                    'serviceExploitant' => $request->get('id') > 0 ? $request->get('id') : null,
                    'periode' => $request->get('periodeDebut'),
                ]) . '?c[]=' . $meteo['id'];
            }
            return $meteo;
        }, $meteoComposants);

        // On supprime les clés (pour que cela soit considéré comme un tableau par la partie JS)
        $meteoComposants = array_values($meteoComposants);

        // On renvoie la météo
        return JsonResponse::create([
            'validation' => $validationDate ? $validationDate->setTimeZone(new \DateTimeZone('Europe/Paris'))->format('c') : false,
            'composants' => $meteoComposants
        ]);
    }

    /**
     * @Route(
     *     "/ajax/meteo/exploitants/{exploitant}/validation/{periodeDebut}",
     *     methods={"GET"},
     *     name="ajax-meteo-exploitants-validation",
     *     requirements={"periodeDebut"="\d{8}"}
     * )
     */
    public function validationPublicationExploitant(Service $exploitant = null, Request $request): Response
    {
        // On protège la route : si on est ROLE_GESTION, on peut usurper sans soucis un exploitant.
        if ($this->isGranted(Service::ROLE_GESTION) || $exploitant === $this->getUser()) {
            // On récupère la date de début de période
            $periodeDebut = \DateTime::createFromFormat('Ymd H:i:s', $request->get('periodeDebut') . ' 00:00:00');

            // Si celle-ci tombe bien un jeudi, alors on continue
            if ($periodeDebut->format('N') == 4) {
                // On récupère l'entity manager
                $em = $this->getDoctrine()->getManager();

                // Si l'information est déjà en base, pas la peine de sauvegarder l'info une deuxième fois
                if (!$validationDate = $em->getRepository(Validation::class)->validationDateParExploitantPeriode($exploitant, $periodeDebut)) {
                    // On calcule la période de fin
                    $periodeFin = (clone $periodeDebut)->add(new \DateInterval('P6D'))->setTime(23, 59, 59);

                    // On ajoute la ligne dans la table de validation
                    $em = $this->getDoctrine()->getManager();
                    $validation = new Validation();
                    $validation->setExploitant($exploitant);
                    $validation->setPeriodeDebut($periodeDebut);
                    $validation->setPeriodeFin($periodeFin);
                    $em->persist($validation);
                    $em->flush();
                    $validationDate = $validation->getAjouteLe();
                }

                // Tout s'est bien passé !
                return JsonResponse::create([ 'statut' => 'ok', 'date' => $validationDate->setTimeZone(new \DateTimeZone('Europe/Paris'))->format('c') ]);
            }
        }

        // Si erreur
        return JsonResponse::create([ 'statut' => 'ko' ]);
    }
}
